<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>OpenCV Image Recognition</title>
    <script async src="opencv.js" type="text/javascript"></script>
    <style>
      canvas {
        box-sizing: border-box;
      }
    </style>
  </head>
  <body>
    <canvas id="outputCanvas" background="black"></canvas>
    <script>
      class FrameData {
        constructor(width, height) {
          // Initialize reusable Mats for downscaled processing resolution
          this.srcMat = new cv.Mat(height, width, cv.CV_8UC4);
          this.grayMat = new cv.Mat(height, width, cv.CV_8UC1);
          this.keypoints = new cv.KeyPointVector();
          this.descriptors = new cv.Mat();
          this.goodMatches = new cv.DMatchVector();
          this.transformationMatrix = null;
        }

        update(imageData) {
          // Update srcMat with new image data
          this.srcMat.data.set(imageData.data);

          // Convert to grayscale
          cv.cvtColor(this.srcMat, this.grayMat, cv.COLOR_BGRA2GRAY);

          // Reinitialize keypoints and descriptors
          this.keypoints = new cv.KeyPointVector();
          this.descriptors.delete();
          this.descriptors = new cv.Mat();

          // Clear good matches by reinitializing
          this.goodMatches = new cv.DMatchVector();
        }

        // Method to clean up Mats when no longer needed
        delete() {
          this.srcMat.delete();
          this.grayMat.delete();
          this.keypoints.delete();
          this.descriptors.delete();
          this.goodMatches.delete();
        }
      }

      class ARFeatureMatcher {
        constructor(
          canvas,
          referenceImageUrl,
          overlayImagePath,
          showMatching = false
        ) {
          this.canvas = canvas;
          this.context = canvas.getContext("2d", { willReadFrequently: true });
          this.referenceImageUrl = referenceImageUrl;
          this.overlayImagePath = overlayImagePath;
          this.isOpenCVInitialized = false;
          this.showMatching = showMatching;
          this.processing = false;
          this.imageCapture = null;
          this.overlayPNGs = [];
          this.currentFrameIndex = 0;

          this.frameData = null;

          // Off-screen canvas for processing with lower resolution
          this.processingCanvas = document.createElement("canvas");
          this.processingContext = this.processingCanvas.getContext("2d", {
            willReadFrequently: true,
          });

          this.transformedCanvas = document.createElement("canvas");
          this.transformedContext = this.transformedCanvas.getContext("2d", {
            willReadFrequently: true,
          });
        }

        async initialize() {
          try {
            await this.initializeOpenCV();
            console.log("OpenCV Initialized");
            await this.setupCVDependentProperties();
            console.log("OpenCV Properties Initialized");
            await this.initializeCamera();
            console.log("Camera Initialized");
            await this.loadReferenceImage(this.referenceImageUrl);
            console.log("Reference Image Loaded");
            await this.loadOverlayPNGs();
            console.log("Overlay PNGs Loaded");
            this.startProcessing();
            console.log("Started Processing");
          } catch (err) {
            console.error("Initialization error: ", err);
          }
        }

        initializeOpenCV() {
          return new Promise((resolve, reject) => {
            try {
              if (typeof cv === "undefined") {
                alert("OpenCV.js not loaded");
                reject("OpenCV.js not loaded");
                return;
              }

              if (cv["onRuntimeInitialized"]) {
                this.isOpenCVInitialized = true;
                resolve();
              } else {
                cv["onRuntimeInitialized"] = () => {
                  this.isOpenCVInitialized = true;
                  resolve();
                };

                if (cv.Mat) {
                  this.isOpenCVInitialized = true;
                  resolve();
                }
              }
            } catch (err) {
              console.error("initializeOpenCV inner error: ", err);
              reject(err);
            }
          });
        }

        async setupCVDependentProperties() {
          if (this.isOpenCVInitialized) {
            this.featureDetector = new cv.AKAZE();
            this.featureDetector.setThreshold(0.0005);
            this.matcher = new cv.BFMatcher();
          } else {
            console.error(
              "setupCVDependentProperties error: OpenCV not initialized."
            );
          }
        }

        async initializeCamera() {
          try {
            const stream = await navigator.mediaDevices.getUserMedia({
              video: { facingMode: "environment" },
            });

            this.video = document.createElement("video");
            this.video.setAttribute("playsinline", "true");
            this.video.muted = true;
            this.video.style.display = "none";
            document.body.appendChild(this.video);

            this.video.srcObject = stream;

            this.video.onloadedmetadata = () => {
              const aspectRatio =
                this.video.videoWidth / this.video.videoHeight;
              const desiredWidth = window.innerWidth;

              // Adjust main visible canvas size
              this.canvas.width = desiredWidth;
              this.canvas.height = desiredWidth / aspectRatio;

              // Off-screen canvas processing at lower resolution for performance
              const scaleFactor = 0.5; // Adjust this scale factor based on performance requirements
              this.processingCanvas.width = this.canvas.width * scaleFactor;
              this.processingCanvas.height = this.canvas.height * scaleFactor;

              this.frameData = new FrameData(
                this.processingCanvas.width,
                this.processingCanvas.height
              );

              // Set the size of the transformedCanvas for final overlay rendering
              this.transformedCanvas.width = this.canvas.width;
              this.transformedCanvas.height = this.canvas.height;
            };

            this.video.onerror = (error) => {
              console.error("Video error: ", error);
              this.stopProcessing();
            };

            await this.video.play();
          } catch (err) {
            console.error("initializeCamera error: ", err);
          }
        }

        async loadReferenceImage(url) {
          let img = new Image();
          img.crossOrigin = "anonymous";
          img.src = url;

          await new Promise((resolve, reject) => {
            img.onload = () => {
              let tempMat = cv.imread(img);
              cv.cvtColor(tempMat, tempMat, cv.COLOR_BGRA2GRAY);
              this.referenceMat = tempMat;
              this.referenceKeypoints = new cv.KeyPointVector();
              this.referenceDescriptors = new cv.Mat();
              this.featureDetector.detectAndCompute(
                tempMat,
                new cv.Mat(),
                this.referenceKeypoints,
                this.referenceDescriptors
              );
              resolve();
            };
            img.onerror = reject;
          });
        }

        async loadOverlayPNGs() {
          const numFrames = 5;
          for (let i = 1; i <= numFrames; i++) {
            let img = new Image();
            img.crossOrigin = "anonymous";
            img.src = `${this.overlayImagePath}/PNG_${String(i).padStart(
              4,
              "0"
            )}.png`;

            await new Promise((resolve, reject) => {
              img.onload = () => {
                let canvas = document.createElement("canvas");
                canvas.width = img.width;
                canvas.height = img.height;
                let context = canvas.getContext("2d", {
                  willReadFrequently: true,
                });

                context.drawImage(img, 0, 0);
                let mat = cv.imread(canvas);
                this.overlayPNGs.push(mat);
                resolve();
              };
              img.onerror = reject;
            });
          }
          this.currentFrameIndex = 0;
        }

        startProcessing() {
          const processFrame = async () => {
            await this.captureAndProcessFrame();
            requestAnimationFrame(processFrame);
          };
          requestAnimationFrame(processFrame);
        }

        captureAndProcessFrame() {
          if (this.processing) return;
          this.processing = true;

          // Draw video frame onto the processing canvas at a reduced resolution
          this.processingContext.drawImage(
            this.video,
            0,
            0,
            this.processingCanvas.width,
            this.processingCanvas.height
          );

          // Get image data from the processing canvas
          let imageData = this.processingContext.getImageData(
            0,
            0,
            this.processingCanvas.width,
            this.processingCanvas.height
          );

          // Update frameData with the new image
          this.frameData.update(imageData);

          // Detect features and match
          this.detectFeaturesAndMatch(this.frameData);

          if (this.frameData.goodMatches.size() > 0) {
            this.calculateTransformationAndOverlay(this.frameData);
          }

          this.processing = false;
        }

        async detectFeaturesAndMatch(frameData) {
          if (!this.isOpenCVInitialized) {
            return;
          }
          try {
            this.featureDetector.detectAndCompute(
              frameData.grayMat,
              new cv.Mat(),
              frameData.keypoints,
              frameData.descriptors
            );
            if (
              !this.referenceDescriptors.empty() &&
              !frameData.descriptors.empty()
            ) {
              let matches = new cv.DMatchVectorVector();
              this.matcher.knnMatch(
                frameData.descriptors,
                this.referenceDescriptors,
                matches,
                2
              );
              let goodMatches = this.filterMatches(matches);
              frameData.goodMatches = goodMatches;
            }
          } catch (err) {
            console.error("detectFeaturesAndMatch error: ", err);
          }
        }

        filterMatches(matches, distanceThreshold = 0.9) {
          let goodMatches = new cv.DMatchVector();
          for (let i = 0; i < matches.size(); ++i) {
            let match = matches.get(i);
            let dMatch1 = match.get(0);
            let dMatch2 = match.get(1);
            if (dMatch1.distance <= dMatch2.distance * distanceThreshold) {
              goodMatches.push_back(dMatch1);
            }
          }
          return goodMatches;
        }

        calculateTransformationAndOverlay(frameData) {
          if (frameData.goodMatches.size() < 5) return;

          let points1 = [];
          let points2 = [];

          for (let i = 0; i < frameData.goodMatches.size(); i++) {
            let match = frameData.goodMatches.get(i);
            points2.push(frameData.keypoints.get(match.queryIdx).pt.x);
            points2.push(frameData.keypoints.get(match.queryIdx).pt.y);
            points1.push(this.referenceKeypoints.get(match.trainIdx).pt.x);
            points1.push(this.referenceKeypoints.get(match.trainIdx).pt.y);
          }

          let mat1 = new cv.Mat(points1.length / 2, 1, cv.CV_32FC2);
          mat1.data32F.set(points1);
          let mat2 = new cv.Mat(points2.length / 2, 1, cv.CV_32FC2);
          mat2.data32F.set(points2);

          let h = cv.findHomography(mat1, mat2, cv.RANSAC);
          if (!h.empty()) {
            this.applyOverlay(h, frameData);
          }
          mat1.delete();
          mat2.delete();
          h.delete();
        }

        applyOverlay(h, frameData) {
          if (h.empty()) return;

          let currentOverlayMat = this.overlayPNGs[this.currentFrameIndex];

          let transformedOverlay = new cv.Mat();
          cv.warpPerspective(
            currentOverlayMat,
            transformedOverlay,
            h,
            new cv.Size(
              this.processingCanvas.width,
              this.processingCanvas.height
            )
          );

          cv.imshow(this.transformedCanvas, transformedOverlay);

          // Draw the video frame first on the main canvas
          this.context.drawImage(
            this.video,
            0,
            0,
            this.canvas.width,
            this.canvas.height
          );

          // Now, draw the transformed overlay with transparency blending on the main canvas
          this.context.drawImage(
            this.transformedCanvas,
            0,
            0,
            this.canvas.width,
            this.canvas.height
          );

          transformedOverlay.delete();
          this.currentFrameIndex =
            (this.currentFrameIndex + 1) % this.overlayPNGs.length;
        }
      }

      window.onload = () => {
        try {
          const referenceSrc = "AR_lethal_weapon_marker.png";
          const overlayPath = "PNG_animation";
          const arFeatureMatcher = new ARFeatureMatcher(
            document.getElementById("outputCanvas"),
            referenceSrc,
            overlayPath,
            true
          );
          arFeatureMatcher.initialize();
        } catch (err) {
          console.error("window.onload error: ", err);
        }
      };

      window.addEventListener("beforeunload", () => {
        cv.destroyAllWindows();
      });
    </script>
  </body>
</html>
